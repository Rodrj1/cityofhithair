export const vulnerability = (
  caster,
  target,
  setTargetAttributes,
  setCasterAttributes,
  waitTimer,
  setMessage,
  casterState,
  targetState,
  setAnimation
) =>
  new Promise((resolve) => {
    const CASTER_MAGIC = caster.magic;
    const CASTER_CHANGE_ATTRIBUTES = setCasterAttributes;
    const CASTER_UPDATE_STATE = casterState;
    const CASTER_POWER = caster.darkMastery;

    const TARGET_NAME = target.name;
    const TARGET_DEFENSE = target.defense;
    const TARGET_CHANGE_ATTRIBUTES = setTargetAttributes;
    const TARGET_UPDATE_STATE = targetState;

    // * Set spell

    const SPELL_POWER = 0.7 - 0.1 * CASTER_POWER;
    const SPELL_DURATION = 1 * CASTER_POWER;
    const MAGIC_COST = 1;
    const MAGIC_CHECK = CASTER_MAGIC - MAGIC_COST;
    const ARMOR_REDUCTION = TARGET_DEFENSE * SPELL_POWER;
    const REMOVED_DEFENSE = TARGET_DEFENSE - TARGET_DEFENSE * SPELL_POWER;

    // * Helpers

    const UPDATE_MESSAGE = setMessage;
    const TIMER = waitTimer;
    const TEXT = `\n${TARGET_NAME}'s defense has been reduced in - ${parseFloat(
      REMOVED_DEFENSE
    ).toFixed(1)}.`;

    // * Spell starts

    if (MAGIC_CHECK >= 0) {
      (async () => {
        await TIMER(1000);

        UPDATE_MESSAGE((prev) => [...prev, TEXT]);

        if (REMOVED_DEFENSE <= 0) {
          CASTER_CHANGE_ATTRIBUTES((prevState) => ({
            ...prevState,
            magic: prevState.magic - MAGIC_COST,
          }));
          TARGET_CHANGE_ATTRIBUTES((prevState) => ({
            ...prevState,
            defense: prevState.defense / prevState.defense,
            vulnerabilityStatus: prevState.vulnerabilityStatus + SPELL_DURATION,
          }));
        } else {
          CASTER_CHANGE_ATTRIBUTES((prevState) => ({
            ...prevState,
            magic: prevState.magic - MAGIC_COST,
          }));
          TARGET_CHANGE_ATTRIBUTES((prevState) => ({
            ...prevState,
            defense: ARMOR_REDUCTION,
            removedDefense: prevState.removedDefense + REMOVED_DEFENSE,
            vulnerabilityStatus: prevState.vulnerabilityStatus + SPELL_DURATION,
          }));
        }

        await TIMER(1000);

        resolve(
          UPDATE_MESSAGE((prev) => [...prev, `\n${TARGET_NAME}'s turn.`]),
          CASTER_UPDATE_STATE(0),
          TARGET_UPDATE_STATE(1),
          setAnimation(""),
        );
      })();
    } else {
      resolve(
        UPDATE_MESSAGE((prev) => [...prev, `\nOut of magic.`]),
        setAnimation(""),
      );
    }
  });

export const updateVulnerabilityStatus = (status, setStatus) => {
  const VULNERABILITY_STATUS = status.vulnerabilityStatus;
  const VULNERABILITY_UPDATE__STATUS = setStatus;

  if (VULNERABILITY_STATUS > 0) {
    VULNERABILITY_UPDATE__STATUS((prevState) => ({
      ...prevState,
      vulnerabilityStatus: prevState.vulnerabilityStatus - 1,
    }));
  }
  if (VULNERABILITY_STATUS == 1) {
    VULNERABILITY_UPDATE__STATUS((prevState) => ({
      ...prevState,
      defense: prevState.defense + prevState.removedDefense,
      removedDefense: 0,
    }));
  }
};
